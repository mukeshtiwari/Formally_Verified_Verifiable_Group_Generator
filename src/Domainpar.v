
Require Import Coq.NArith.NArith
  Verigen.Sha256 Verigen.Bytestring
  Verigen.Fermat
  Verigen.Functions
  Znumtheory Lia
  Zdiv Zpow_facts.
From Coq Require Import String Ascii.
Open Scope N_scope.

(* https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf*)
(* Verifiable Canonical Generation of the Generator g  *)
(* Input p, q, and domain_seed *)
(* We assume that that the prime p q has been validated and 
   generated by using  domain_parameter_seed *)
Module Type Prime.
  Parameters (p q k domain_parameter_seed ggen index : N).
  Axiom prime_p : prime (Z.of_N p).
  Axiom p_len : 1024 <= N.size p. 
  Axiom prime_q : prime (Z.of_N q).
  Axiom q_len : 160 <= N.size q. 
  Axiom k_gteq_2 : 2 <= k.
  Axiom safe_prime : p = k * q + 1.
  Axiom ggen_hyp : ggen = 0x6767656e.
  Axiom index_8bit : 0 <= index < 0xff.
End Prime.

Module Comp (P : Prime).
Section Generator.

  Let p := P.p.
  Let q := P.q.
  Let k := P.k.
  Let domain_parameter_seed := P.domain_parameter_seed.
  Let ggen : N := P.ggen. 
  Let index := P.index.
  Let uh : string :=
    Bytestring.to_string 
    (Bytestring.parse
      ((Sha256.big_endien_list_N domain_parameter_seed) ++
      (Sha256.big_endien_list_N ggen) ++
      (Sha256.big_endien_list_N index))).
  

  
  Definition append_values (count : N) : string :=
    uh ++ 
    Bytestring.to_string 
      (Bytestring.parse 
        (if count <? 0xff then 
          ((Sha256.big_endien_list_N 0) ++
           (Sha256.big_endien_list_N count))
          else 
          (Sha256.big_endien_list_N count))).

 
  
  Inductive Tag : Type :=
  | Invalid : Tag
  | Valid : N -> Tag.


  Local Fixpoint compute_gen_slow (n : nat) (m : N) : Tag :=
    match n with 
    | 0%nat => Invalid 
    | S n' => 
      let U := append_values m in
      (*
        This W can be arbitrary N but we can replace it by W % p without 
        chaning the results. See the fast function and the proof that 
        slow and fast are same. 
      *) 
      let W := sha256_string U in
      let g := Npow_mod W k p in 
      if g <? 2 then compute_gen_slow n' (m + 1) else Valid g
    end.
  
  Local Fixpoint compute_gen_fast (fuel : nat) (m : N) : Tag :=
    match fuel with 
    | 0%nat => Invalid 
    | S fuel' => 
      let U := append_values m in
      let W := N.modulo (sha256_string U) p in
      let g := Npow_mod W k p in 
      if g <? 2 then compute_gen_fast fuel' (m + 1) else Valid g
    end.


  Definition compute_generator := 
    compute_gen_fast (2^16) 1.
  
  Lemma compute_gen_slow_fast_equal : forall n m, 
    compute_gen_slow n m = compute_gen_fast n m.
  Proof.
    induction n.
    - simpl; intros ?.
      reflexivity.
    - simpl; intros ?.
      remember
        (sha256_string
         (append_values m))%N as wt.
      rewrite <-Nmod_reduce_pow.
      destruct (Npow_mod wt k p) eqn:Ht.
      simpl. apply IHn.
      destruct (N.pos p0 <? 2) eqn:Htt.
      apply IHn. reflexivity.
      apply P.prime_p.
  Qed.


  Lemma p_pos : (0 < (Z.of_N p))%Z.
  Proof.
    pose proof P.prime_p as Hp.
    pose proof P.prime_q as Hq.
    pose proof P.k_gteq_2 as Hk.
    pose proof P.safe_prime as Hs.
    lia.
  Qed.
  
  Lemma q_pos : (0 < (Z.of_N q))%Z.
  Proof. 
    pose proof P.prime_p as Hp.
    pose proof P.prime_q as Hq.
    pose proof P.k_gteq_2 as Hk.
    pose proof P.safe_prime as Hs.
    pose proof (prime_ge_2 (Z.of_N q) Hq).
    lia.
  Qed.

  Lemma lt_1_p : (1 < (Z.of_N p))%Z.
  Proof. 
    pose proof P.prime_p as Hp.
    pose proof P.prime_q as Hq.
    pose proof P.k_gteq_2 as Hk.
    pose proof P.safe_prime as Hs.
    pose proof (prime_ge_2 (Z.of_N p) Hp).
    lia.
  Qed.

  
   (* g^q mod p = 1 *)
  Theorem g_is_generator_of_subgroup_of_order_q : forall (t g : N), 1 < t < p ->
    (Z.of_N g = Zpow_mod (Z.of_N t) (Z.of_N k) (Z.of_N p))%Z -> 
    Zpow_mod (Z.of_N g) (Z.of_N q) (Z.of_N p) = 1%Z.
  Proof.
    pose proof P.prime_p as Hp.
    pose proof P.prime_q as Hq.
    pose proof P.k_gteq_2 as Hk.
    pose proof P.safe_prime as Hs.
    intros ? ? Ht Hg.
    rewrite Zpow_mod_correct.
    rewrite Zpow_mod_correct in Hg.
    rewrite Hg. 
    rewrite <- Zpower_mod.
    rewrite <- Z.pow_mul_r.
    assert (Htt : (Z.of_N k * Z.of_N q = Z.of_N p - 1)%Z) by lia.
    rewrite Htt.
    assert (Hpt: (Z.of_N p - 1 = Z.of_N (p - 1))%Z).
    lia. rewrite Hpt.
    rewrite <-Zpow_mod_correct.
    apply fermat_little_Z.
    exact Hp.
    apply Zrel_prime_neq_mod_0. lia.
    assert (Hrel: rel_prime (Z.of_N t) (Z.of_N p)).
      apply rel_prime_le_prime. auto. lia.
    assumption. 
    all:lia.
  Qed.

  

  
  (* proof that it generates a correct generator *)
  (* g is the generator of order q *)
  (* g ^ q mod p = 1 *)
  Lemma correct_compute_gen : forall n m g, compute_gen_fast n m = Valid g -> 
    Zpow_mod (Z.of_N g) (Z.of_N q) (Z.of_N p) = 1%Z.
  Proof.
    induction n.
    + simpl; intros. inversion H.
    + simpl; intros.
      remember ((append_values m)) as wt.
      remember (sha256_string wt) as W.
      destruct (Npow_mod (W mod p) k p <? 2) eqn:Hw.
      apply IHn with (m := m + 1). exact H.
      inversion H; clear H.
      eapply g_is_generator_of_subgroup_of_order_q with (t := Nmod W p).
      apply N.ltb_ge in Hw.
      assert (Hk : 2 <= k). 
      apply P.k_gteq_2.
      assert (Hp : 2 <= p).
      unfold p.
      pose proof (prime_ge_2 (Z.of_N P.p) P.prime_p).
      lia. split.
      assert (W mod p = 0 \/ W mod p = 1 \/ 2 <= W mod p).
      remember (W mod p) as Wp. lia.
      destruct H as [H | [H | H]].
      rewrite wp_mod_zero in Hw.
      lia. apply P.prime_p.
      exact Hk. exact Hp.
      exact H.
      rewrite wp_mod_one in Hw.
      lia. apply P.prime_p.
      exact Hk. exact Hp.
      exact H. lia.
      apply N.mod_lt. 
      lia.
      remember (W mod p) as wp.
      apply zmod_nmod.
      apply P.prime_p.
  Qed.


  (* generators are in range 2 <= g < p *)
  Lemma gen_generator_range : forall (n : nat) (m g : N), 
    Valid g = compute_gen_slow n m  -> 2 <= g < p.
  Proof.
    induction n.
    - simpl; intros ? ? Hg; 
      inversion Hg.
    - simpl; intros ? ? Hg.
      destruct (Npow_mod (sha256_string (append_values m)) k p <? 2) eqn:Ht.
      pose proof (IHn _ _ Hg). exact H.
      inversion Hg; clear Hg.
      remember (Npow_mod (sha256_string (append_values m)) k p) as W.
      split.
      apply N.ltb_ge in Ht. exact Ht.
      rewrite <-npow_mod_exp_unary_binary_eqv in HeqW.
      pose proof Npow_mod_unary_bound (N.to_nat k) 
      (sha256_string (append_values m)) p (P.prime_p).
      lia. apply P.prime_p.
  Qed.

  
  Local Fixpoint verify_generator_rec (n : nat) (m g : N) : bool :=
    match n with
    | 0%nat => false (* reached the end *)
    | S n' =>
      let U := append_values m in 
      let W := sha256_string U in 
      let y := Npow_mod W k p in 
      if y <? 2 then verify_generator_rec n' (m + 1) g
      else g =? y
    end.

  (* procedure that computes the validity of a generator. 
     We prove that when compute_generator returns a 
     generator, verify_generator always returns true. *)
  Definition verify_generator (g : N) : bool :=
    if negb (andb (2 <=? g) (g <? p)) then false
    else if negb (Npow_mod g q p =? 1) then false
    else verify_generator_rec (2^16) 1 g.
    
    
  Lemma gen_generator_always_verified_forward : forall (n : nat) (m g : N), 
    Valid g = compute_gen_slow n m -> verify_generator_rec n m g = true.
  Proof.
    induction n.
    - simpl; intros ? ? Hg.
      congruence.
    - simpl; intros ? ? Hg.
      destruct (Npow_mod (sha256_string (append_values m)) k p <? 2) eqn:Ht.
      apply IHn. exact Hg.
      inversion Hg.
      apply N.eqb_refl.
  Qed.


  Lemma gen_generator_always_verified_backward : forall (n : nat) (m g : N), 
    verify_generator_rec n m g = true -> Valid g = compute_gen_slow n m.
  Proof.
    induction n.
    - simpl; intros ? ? Hg.
      congruence.
    - simpl; intros ? ? Hg.
      destruct (Npow_mod (sha256_string (append_values m)) k p <? 2) eqn:Ht.
      apply IHn.
      exact Hg.
      apply N.eqb_eq in Hg.
      rewrite Hg.
      reflexivity.
  Qed.


  Lemma gen_generator_always_verified : forall (n : nat) (m g : N), 
    Valid g = compute_gen_slow n m <-> verify_generator_rec n m g = true.
  Proof.
    intros *; split; intro H.
    eapply gen_generator_always_verified_forward; assumption.
    eapply gen_generator_always_verified_backward; assumption.
  Qed.


  (* Proof that whenever we have a generator, then verifier 
    returns true for the same generator. 
  *)
  Lemma generator_verifier_correctness_forward : forall g,
    Valid g = compute_generator -> verify_generator g = true.
  Proof.
    intros ? Hg.
    unfold compute_generator in Hg.
    rewrite <-compute_gen_slow_fast_equal in Hg.
    unfold verify_generator.
    assert (Ht : 2 <= g < p).
    eapply gen_generator_range with (n := (2^16)%nat) (m := 1).
    exact Hg.
    assert (Hw : Npow_mod g q p = 1).
    apply N2Z.inj.
    rewrite zmod_nmod.
    eapply correct_compute_gen with (n := (2^16)%nat) (m := 1).
    symmetry. rewrite <-compute_gen_slow_fast_equal.
    exact Hg. apply P.prime_p.
    destruct (negb ((2 <=? g) && (g <? p))) eqn:Hf.
    apply Bool.negb_true_iff in Hf.
    apply Bool.andb_false_iff in Hf.
    destruct Hf as [Hf | Hf].
    apply N.leb_gt in Hf. lia.
    apply N.ltb_ge in Hf. lia.
    assert (Hv : Npow_mod g q p = 1).
    apply N2Z.inj.
    rewrite zmod_nmod.
    apply correct_compute_gen with (n := (2^16)%nat) (m := 1).
    symmetry. rewrite <-compute_gen_slow_fast_equal.
    exact Hg. apply P.prime_p.
    destruct (negb (Npow_mod g q p =? 1))  eqn:Hz.
    apply Bool.negb_true_iff in Hz.
    apply N.eqb_neq in Hz. lia.
    apply gen_generator_always_verified.
    exact Hg.
  Qed.

  

  Lemma generator_verifier_correctness_backward : forall g,
    verify_generator g = true -> Valid g = compute_generator.
  Proof.
    intros g Hg.
    unfold verify_generator in Hg.
    unfold compute_generator.
    destruct (negb ((2 <=? g) && (g <? p))) eqn:Ht.
    apply Bool.negb_true_iff in Ht.
    apply Bool.andb_false_iff in Ht.
    destruct Ht as [Ht | Ht].
    congruence. congruence.
    clear Ht.
    destruct (negb (Npow_mod g q p =? 1)) eqn:Ht.
    congruence.
    rewrite <-compute_gen_slow_fast_equal.
    apply gen_generator_always_verified_backward.
    exact Hg.
  Qed.

  Lemma generator_verifier_correctness : forall g,
    verify_generator g = true <-> Valid g = compute_generator.
  Proof.
    intros *; split; intro H.
    apply generator_verifier_correctness_backward; assumption.
    apply generator_verifier_correctness_forward; assumption.
  Qed.



    

End Generator.
End Comp.  



